# 1주차(웹 & 네트워크)

## 예상 질문 리스트

### HTTP/HTTPS 파트
<details>
<summary>1. HTTP와 HTTPS에 대해 설명해주세요</summary>
<div>
HTTP는 Hypertext Transfer Protocol의 약자로, 클라이언트/서버 모델에서 데이터를 주고받기 위한 프로토콜입니다. 7계층의 프로토콜로, TCP/IP 위에서 동작하며, 80번 포트를 사용합니다. HTTP는 상태를 가지고 있지 않는 Stateless 프로토콜이며 e커머스 같은 상태가 필요한 작업들을 위한 쿠키와 세션이 존재합니다.
HTTP는 클라이언트와 서버 사이에서 데이터를 주고 받을 떄 텍스트 형태로 주고 받으며, 누군가 네트워크에서 신호를 가로채면 내용이 노출될 수 있다는 보안적인 이슈가 존재합니다.
이를 보완하기 위해서 고안된 것이 바로 HTTP Secure라고도 불리는 HTTPS 이며 HTTP에 데이터 암호화를 추가하여 보안성을 강화한 프로토콜입니다. 443 포트를 사용하고, HTTP 레이어 바로 밑단에 SSL이나 TLS 프로토콜을 추가하여, 서버와 클라이언트 사이에서의 모든 통신 내용이 암호화됩니다.
</div>
</details>

<details>
<summary>2. 세션과 쿠키란? 사용 이유에 대해 설명</summary>
<div>
세션과 쿠키는 웹상에서 사용자의 상태 정보를 유지하고, 사용자 경험을 개선하기 위해 사용되는 기술입니다. 이들은 HTTP 프로토콜의 비연결성과 무상태성을 보완하는 역할을 합니다.

### 세션(Session)
세션은 서버 측에서 생성되는 일종의 식별자로, 사용자가 웹 서버에 접속할 때마다 임시로 생성됩니다. 사용자의 정보는 서버에 저장되며, 보안성이 높지만 서버의 부하를 증가시킬 수 있습니다.
세션은 주로 사용자의 로그인 상태나 접속 정보 등을 유지하기 위해 사용되며 세션을 통해 사용자가 여러 페이지를 이동하더라도 로그인 상태를 유지할 수 있습니다.
### 쿠키(Cookie)
쿠키는 클라이언트(브라우저) 측에 저장되는 작은 데이터 파일로, 사용자의 웹 사이트 방문 정보나 선호도 등을 저장합니다. 쿠키는 사용자가 웹 사이트에 다시 접속할 때 해당 정보를 서버에 전송하여 사용자 맞춤형 서비스를 제공할 수 있게 합니다.
쿠키를 사용하는 이유는 사용자의 편의성을 높이고, 웹 사이트의 사용성을 개선하기 위해 사용됩니다. 예를 들어, 쿠키를 통해 사용자의 로그인 정보, 장바구니 정보, 언어 설정 등을 기억하게 할 수 있습니다.
세션과 쿠키는 HTTP의 무상태성과 비연결성을 개선하기 위해 나온 방법으로 e커머스처럼 상태가 필요한 경우 사용자의 정보를 각각 서버(세션)와 클라이언트(쿠키) 측에서 관리하는 방법입니다. 보안성이 중요한 정보는 세션을 통해 서버 측에서 관리하고, 사용자의 편의성을 위한 정보는 쿠키를 통해 클라이언트 측에서 관리하는 것이 일반적입니다. 
</div>
</details>

<details>
<summary>
3. http1, 2, 3 의 차이는 무엇인가?
</summary>
<div>

**HTTP/1.0**:
- 연결마다 하나의 요청과 응답만 처리하는 클라이언트-서버 모델을 사용합니다.
- 텍스트 기반의 프로토콜로, 헤더 정보와 데이터가 동일한 연결을 통해 전송됩니다.
- 성능과 효율성이 떨어지는 단점이 있으며, 여러 개의 리소스를 동시에 로드하기 어렵습니다.
<br>

**HTTP/1.1**:

- **지속 연결(Persistent Connection)**과 **파이프라이닝(Pipelining)**을 도입하여 한 번의 TCP 초기화 이후, keep-alive 옵션으로 일정 시간 동안 연결 상태를 유지하며, 클라이언트는 앞 요청의 응답을 기다리지 않고 순차적으로 요청을 전송할 수 있게 되었습니다(하지만, 서버에서는 순서대로 처리해야 해서 병목 현상이 발생하고 HOL 문제가 발생). 
- 헤더 필드의 압축을 통해 일부 성능 향상을 이루었지만, 여전히 성능이 제한됩니다.(쿠키와 같은 다양한 메타 정보가 헤더에 들어가서 보내려 하는 데이터보다 header가 더 커지게 되는 Fat message header 문제가 존재)
![alt text](image.png)

<br>

**HTTP/2**:
- 이진 프레임 형식과 헤더 압축을 도입하여 효율성을 개선했습니다.
- **다중 스트림(Multiplexing)을 지원하여 하나의 연결로 동시에 여러 요청과 응답을 처리**할 수 있습니다.
- **서버 푸시(Server Push)를 통해 서버는 클라이언트 요청 없이 리소스를 전송할 수** 있습니다.
- 보안을 위해 기본적으로 TLS(SSL)을 사용하도록 권장하며 그 위에 binary framing layer가 올라가서 동작합니다. (메시지가 프레임으로 나뉘면 헤더는 헤더 프레임, 데이터는 데이터 프레임으로 나뉨.) 
![이진 프레임 구조](image-1.png)
![다중 스트림 구조](image-2.png)
<br>

#### Appendix
Stream : 구성된 연결 내에서 전달되는 바이트의 양방향 흐름으로 하나 이상의 메시지가 전달될 수 있습니다.
Message : 논리적 요청 또는 응답 메시지에 매핑되는 프레임의 전체 시퀀스입니다.
Frame : http/2에서 통신의 최소 단위로 각 최소 단위에는 하나의 프레임 헤더가 포함됩니다.
즉, 상위 레벨에서는 스트림으로 묶고 하위 레벨에서는 프레임으로 쪼개져서 통신이 이루어집니다. 각 스트림에는 양방향 메시지 전달에 사용되는 고유 식별자와 우선순위 정보(선택적)가 존재하며 모든 통신은 클라이언트와 서버 사이에 하나의 tcp 연결만을 사용하며 전달될 수 있는 양방향 스트림의 수는 제한이 없습니다. 즉, tcp를 복수로 뚫지 않습니다.


**HTTP/3**:
- 전체적으로 새로운 전송 프로토콜로, **QUIC(Quick UDP Internet Connections)을 기반으로** 합니다.
- UDP를 사용하여 혼잡 제어 및 오류 복구 기능을 더 효과적으로 수행하며, 연결 설정 및 해제에 대한 지연을 감소시킵니다.
- 하나의 연결로 다수의 병렬 스트림을 전송하며, 스트림 간에 영향을 주지 않고 데이터를 동시에 전송합니다.
- 보통 tcp에서는 소켓 번호로 ip주소+포트 번호를 쓰는데 QUIC에서는 독립적으로 connection id를 사용하기 때문에 ip주소가 바뀌어도 연결이 유지됩니다.
- QUIC의 연결 설정 과정이 TLS1.3과 밀결합되어 있는 반면 TCP는 TLS와 서로 독립적이라서 따로 따로 뚫지만 QUIC 은 새로 만들때 그냥 같이 써야해서 같이합니다. (QUIC이 TLS1.3을 사용한 주된 이유는 handshake에 더 적은 라운드 트립이 필요하도록 바뀌었기 때문으로 프로토콜 지연을 줄여주는 효과가 있음.)

(https://suminn0.tistory.com/143)
![TLS](image-3.png)

</div>
</details>

<details>
<summary>
4. CORS란? 문제 해결 방법에 대해 서술
</summary>
<div>

### CORS(Cross-Origin Resource Sharing)란?

CORS는 웹 브라우저에서 보안을 유지하면서 다른 출처의 리소스를 안전하게 요청할 수 있도록 하는 메커니즘입니다. 서버는 HTTP 헤더를 통해 다른 출처의 요청을 허용할지 결정하며, 이는 원본 사이트의 모방을 방지하고 다른 출처의 데이터 요청을 제한함으로써 공격으로부터 보호하는 데 필요합니다.

#### CORS의 필요성
- 보안 강화: 웹 애플리케이션은 선택된 리소스에 대해 다른 출처의 접근을 허용함으로써, 원본 사이트를 모방하거나 사용자 정보를 도용하는 등의 무단 접근 및 해킹 가능성을 줄일 수 있습니다.
- 통합 용이성: 클라이언트 웹 애플리케이션이 다른 도메인의 리소스와 상호 작용할 수 있게 함으로써, third party API 및 리소스를 클라이언트 측 코드에서 참조하는 것을 용이하게 합니다. 예를 들어, 동영상 플랫폼 API에서 동영상을 가져오거나 글꼴 라이브러리의 글꼴을 사용하는 등의 작업에 활용됩니다.
#### CORS 해결 방법
- 서버 측 설정 변경: 서버에서 특정 출처 또는 모든 출처에 대한 요청을 허용하도록 설정을 변경합니다. 예를 들어, Spring Boot에서는 @CrossOrigin 어노테이션을 사용하거나, WebMvcConfigurer를 구현하여 글로벌 CORS 설정을 할 수 있습니다.
- 프록시 서버 사용: 클라이언트와 서버 사이에 프록시 서버를 두어, 모든 클라이언트 요청을 프록시를 통해 서버로 전달하고, 서버의 응답을 클라이언트에게 전달하는 방식으로 CORS 문제를 우회할 수 있습니다.

</div>
</details>

<details>
<summary>
5. stateful과 stateless 의 차이점이 무엇인지에 대해 설명
</summary>
<div>

#### Stateful
Stateful(상태 유지) 시스템은 사용자의 상태 정보를 저장하고 이를 기반으로 다음 행동을 결정합니다. 예를 들어, 웹 애플리케이션에서 로그인 세션 관리는 Stateful한 예입니다. 사용자가 로그인하면, 그 사용자의 정보(예: 세션 ID)가 서버에 저장되고, 사용자가 다음 요청을 할 때마다 서버는 해당 정보를 참조하여 사용자를 인식합니다. 이를 통해 사용자마다 개인화된 서비스를 제공할 수 있습니다.

#### Stateless
Stateless(상태 비유지) 시스템은 사용자의 상태 정보를 저장하지 않습니다. 즉, 각 요청이 독립적으로 처리되며, 이전 요청의 정보가 후속 요청에 영향을 주지 않습니다. 예를 들어, HTTP 프로토콜은 Stateless 프로토콜입니다. 클라이언트가 서버에 요청을 보낼 때 마다, 각 요청은 서로 독립적으로 처리되며, 서버는 이전 요청에 대한 정보를 저장하거나 참조하지 않습니다. 이러한 특성은 서버의 복잡성을 줄이고 확장성을 높이는 데 도움이 됩니다.

둘의 차이점은 상태 정보 저장 여부와 응답 방식에 차이가 있으면 Stateful의 경우엔 저장하고 관리한 상태 정보를 기반으로 응답을 결정하는 반면 Stateless는 상태 정보를 유지하지 않고 각 요청을 독립적으로 처리합니다. 따라서 전자의 경우 상태 정보 관리를 위한 리소스가 필요할 수 있으며 이는 시스템의 복잡성을 증가시킬 수 있습니다.
</div>
</details>

<details>
<summary>
6. SSL/TLS HandShaking 에 대해 설명
</summary>
<div>

SSL(Secure Sockets Layer)과 TLS(Transport Layer Security)는 인터넷 상에서 데이터를 암호화하여 전송하는 기술로, 민감한 정보를 안전하게 전송하기 위해 사용됩니다. SSL은 TLS의 전신이며, 현재는 TLS가 더 널리 사용됩니다. SSL/TLS Handshaking은 클라이언트와 서버 간의 안전한 연결을 설정하는 과정입니다.

클라이언트 헬로(Client Hello): 통신을 시작하는 클라이언트가 서버에게 사용 가능한 암호화 방식, TLS 버전, 임의의 난수(random number) 등을 전송합니다.

서버 헬로(Server Hello): 서버는 클라이언트의 메시지를 받고, 클라이언트와 공통으로 사용할 수 있는 암호화 방식, TLS 버전, 서버의 임의의 난수 등을 선택하여 응답합니다.

서버 인증 및 키 교환(Server Certificate and Key Exchange): 서버는 자신의 인증서를 클라이언트에게 전송합니다. 클라이언트는 인증서의 유효성을 확인하고, 서버의 공개키를 획득합니다. 이 공개키를 이용하여 세션 키를 암호화하여 서버에게 전송합니다.

클라이언트 키 교환(Client Key Exchange): 클라이언트는 서버의 공개키를 사용하여 암호화된 프리마스터 시크릿(premaster secret)을 생성하고 이를 서버에게 전송합니다. 서버는 개인 키를 사용하여 premaster secret(클라이언트가 보낸 키)을 해독합니다. 그런 다음 서버와 클라이언트는 모든 통신의 대칭 암호화에 사용되는 세션 키를 계산합니다.

핸드세이크 완료: 서버와 클라이언트는 서로에게 "Finished" 메시지를 전송하여 핸드셰이킹 과정이 성공적으로 완료되었음을 알립니다. 이 시점부터 클라이언트와 서버 간에 교환되는 데이터는 모두 암호화되어 전송됩니다.

![ssl/tls handshake](image-4.png)
</div>
</details>

<details>
<summary>
7. SSL ,TLS 가 무엇인가요?
</summary>
<div>

SSL(Secure Sockets Layer)과 TLS(Transport Layer Security)는 인터넷 상의 데이터 전송을 안전하게 보호하기 위한 프로토콜입니다. 이들은 개인 정보, 인증, 데이터 무결성을 보호하며, 특히 온라인 거래와 같은 중요한 정보가 오가는 통신을 암호화하여 보안을 강화합니다. SSL은 TLS의 전신으로, 시간이 지나면서 TLS로 발전했습니다.

#### SSL과 TLS의 역할
- 데이터 암호화: 웹사이트와 브라우저 간에 전송되는 데이터를 암호화하여, 해커들이 개인 또는 금융 정보에 접근하는 것을 방지합니다.
- 통신 보안 강화: 웹 브라우징, 이메일, VoIP와 같은 애플리케이션을 위해 컴퓨터 네트워크 상에서 통신 보안을 제공합니다.

#### SSL과 TLS의 차이점
- 보안 강화: TLS는 SSL의 취약점을 해결한 업그레이드 버전으로, 더 강화된 보안 기능을 제공합니다.
- 표준화: TLS는 1999년 IETF(Internet Engineering Task Force)에 의해 표준화된 SSL의 후속 버전입니다.(TLS 1.0은 SSL 3.0 의 개선 버전으로 시작)

SSL과 TLS는 웹사이트의 신뢰도를 높이고 인터넷 연결을 보호하는 데 중요한 역할을 합니다. 이 프로토콜들은 모든 종류의 정보 교환을 보호하는 데 필수적이며, 전자상거래뿐만 아니라 로그인 정보와 같은 중요 데이터의 안전한 전송을 보장합니다. 

</div>
</details>

<details>
<summary>
8. REST, RESTful이란 무엇일까요?
</summary>
<div>
REST는 인터넷상에서 클라이언트와 서버 간의 상호작용을 규정하기 위해 고안되었으며, 웹 기술을 사용하여 구현됩니다. RESTful은 REST 원칙을 준수하는 웹 서비스를 의미합니다. 

#### REST 구성 요소
- 자원(Resource) : HTTP URI
- 자원에 대한 행위(Verb) : HTTP Method
- 자원에 대한 행위의 내용 (Representations) : HTTP Message Pay Load

#### REST 주요 특징
- 클라이언트-서버 구조(Client-Server Architecture): 클라이언트와 서버가 독립적으로 동작할 수 있도록 분리됩니다. 이를 통해 각각의 구성 요소가 개별적으로 발전할 수 있습니다.

- 무상태(Stateless): 각 요청은 독립적이며, 이전 요청의 상태 정보를 저장하지 않습니다. 서버는 클라이언트로부터 온 요청만을 처리하며, 이 요청에는 필요한 모든 정보가 포함되어 있어야 합니다.

- 캐시 처리 가능(Cacheable): 서버 응답은 캐싱이 가능하도록 표시될 수 있습니다. 이를 통해 클라이언트는 응답을 재사용하여 애플리케이션의 효율성과 성능을 향상시킬 수 있습니다.

- 계층형 시스템(Layered System): 클라이언트는 서버가 직접적으로 연결되어 있는지, 중간에 다른 계층이 있는지 알 수 없습니다. 이는 시스템의 확장성을 향상시킵니다.

- 코드 온 디맨드(Code on Demand, 선택적): 서버는 실행 가능한 코드를 클라이언트에 전송할 수 있습니다. 이는 클라이언트의 기능을 임시적으로 확장할 수 있게 합니다.

- 일관된 인터페이스(Uniform Interface): 일관된 인터페이스를 통해 시스템 간의 상호작용을 단순화합니다. 이 원칙에는 리소스의 식별, 리소스에 대한 표현, 자기 서술적 메시지, 하이퍼미디어를 통한 애플리케이션 상태의 엔진 등이 포함됩니다.

RESTful 웹 서비스는 이러한 원칙을 따르며, 주로 HTTP 메소드(GET, POST, PUT, DELETE 등)를 사용하여 리소스에 접근하고 조작합니다. RESTful 아키텍처를 사용함으로써, 개발자들은 보다 유연하고 확장 가능한 웹 서비스를 구축할 수 있습니다.
</div>
</details>

<details>
<summary>
9. URL과 URI는 뭐가 다를까?
</summary>
<div>

#### URI (Uniform Resource Identifier)
URI는 인터넷 상의 자원을 고유하게 식별하거나 이름을 붙이기 위한 문자열입니다.
URI는 자원의 위치나 이름을 나타낼 수 있으며, URL과 URN (Uniform Resource Name)을 포함하는 더 넓은 개념입니다.
ex) mailto:example@example.com (URN), http://example.com/page (URL)
#### URL (Uniform Resource Locator)
URL은 인터넷 상의 자원이 위치한 곳을 나타내기 위한 특정한 형태의 URI입니다.
URL은 자원에 접근하기 위한 구체적인 방법과 위치를 포함합니다. 즉, 해당 자원을 찾기 위한 주소 역할을 합니다.
ex) http://example.com/page

#### 차이점
모든 URL은 URI입니다. 하지만 모든 URI가 URL인 것은 아닙니다. URI는 자원의 위치(URL) 또는 이름(URN)을 나타낼 수 있지만, URL은 오직 자원의 위치만을 나타냅니다.
URL은 자원에 접근하기 위한 경로를 제공하는 반면, URI는 자원을 식별하거나 이름을 붙이는 데 사용됩니다.
즉, URL은 '어디에' 있는지를 알려주고, URI는 '무엇인지'를 식별합니다.

</div>
</details>

<details>
<summary>
10. PUT과 PATCH의 차이에 대해 설명해주세요.
</summary>
<div>

HTTP 메소드인 PUT과 PATCH는 모두 리소스를 업데이트하는 데 사용되지만, 그 방식에서 차이가 있습니다. PUT은 전체 리소스를 업데이트하는 반면, PATCH는 리소스의 일부분만 업데이트합니다. 예를 들어, PUT 요청을 보내면 리소스의 모든 필드가 업데이트되지만, PATCH 요청을 보내면 특정 필드만 업데이트할 수 있습니다.

#### PUT과 PATCH의 주요 차이점
PUT: 전체 리소스를 업데이트하므로, 업데이트하려는 리소스의 모든 정보를 요청에 포함해야 합니다. 이는 리소스의 일부만 변경하고자 할 때 비효율적일 수 있습니다.
PATCH: 리소스의 특정 부분만을 업데이트하기 때문에, 변경하고자 하는 정보만 요청에 포함하면 됩니다. 이는 효율적인 데이터 전송과 빠른 업데이트를 가능하게 합니다.

</div>
</details>

<details>
<summary>
11. GET과 POST의 차이점에 대해서 설명해보세요.
</summary>
<div>

GET 메소드는 서버로부터 정보를 조회하기 위해 사용됩니다. 데이터를 URL의 쿼리 스트링을 통해 전송하며, 이 데이터는 URL에 노출됩니다. GET 요청은 브라우저에 의해 캐시될 수 있으며, 북마크와 검색 엔진 크롤링에 적합합니다.
POST 메소드는 서버에 데이터를 제출하여 리소스를 생성하거나 업데이트하기 위해 사용됩니다. 데이터는 요청 본문(body)에 포함되어 전송되며, URL에는 노출되지 않습니다. POST 요청은 캐시되지 않으며, 브라우저 히스토리에도 저장되지 않습니다.

</div>
</details>

